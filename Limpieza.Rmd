---
title: "Limpieza_Datos"
author: "Iyán Álvarez, Azahara Martínez, Juan Alcaraz Otón"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

```{r Librerias}
library(lubridate)
library(tidyr)
library(tidyverse)
library(scales)
library(dplyr)
library(stringr)
library(zoo)
library(purrr)
library(forecast)
```

# INTRODUCCIÓN

Para el desarrollo del análisis, se han utilizado dos bases de datos principales. La primera contiene información relacionada con el turismo en España, desglosada por comunidades autónomas y provincias, e incluye variables como el número de viajeros y pernoctaciones registradas a lo largo de varios años. La segunda base de datos corresponde al sector servicios, específicamente a la ocupación en dicho sector, que se analizará posteriormente para establecer relaciones con la evolución del turismo.

# IMPORTACIÓN Y LIMPIEZA

Con el fin de garantizar que los datos utilizados estén siempre actualizados, se ha optado por realizar la importación directamente desde la URL de origen, en lugar de utilizar copias locales. De este modo, si los archivos son modificados o actualizados en la fuente oficial, el código podrá acceder automáticamente a la versión más reciente.

```{r Enlaces de descarga}
url_ocupacion<-"https://www.ine.es/jaxiT3/files/t/es/csv_bdsc/65311.csv?nocab=1"
url_turismo<-"https://www.ine.es/jaxiT3/files/t/es/csv_bdsc/67190.csv?nocab=1"
```

Antes de proceder a la carga definitiva, se ha comprobado la codificación (_encoding_) de cada archivo, con el objetivo de evitar posibles problemas de lectura o visualización de caracteres especiales en las tablas. Esto se ha realizado aplicando la función correspondiente para identificar el tipo de codificación de cada dataset.

```{r Codificación de los archivos}
guess_encoding(url_turismo)
guess_encoding(url_ocupacion)
```

Tras ver los resultados, lo mejor es usar la codificación UTF-8.

Finalmente, los datos se han importado utilizando la función `read_csv()`, creando dos dataframes principales:

```{r Importación}
df_Turismo <- read.csv(url_turismo,
                       header = TRUE,
                       sep = ";",
                       encoding = "UTF-8")

df_Ocupacion <- read.csv(url_ocupacion,
                       header = TRUE,
                       sep = ";",
                       dec = ",",
                       encoding = "UTF-8")
```

# CARACTERÍSTICAS GENERALES

## TURISMO

Una vez importados los datos, se procede al análisis de las características generales del primer conjunto, correspondiente al turismo en España. Este dataset recopila información sobre el número de viajeros y las pernoctaciones registradas a lo largo del tiempo, desglosadas por comunidades y provincias.

Las variables incluidas son las siguientes:

- Totales.Territoriales: columna con un único valor (“Total Nacional”). No aporta información relevante para el análisis, por lo que se eliminará en fases posteriores.

- CCAA: identifica la comunidad o ciudad autónoma correspondiente a cada registro.

- Provincias: especifica la provincia asociada a cada comunidad. Posteriormente será eliminada ya que la limitación de espacio no nos permite analizar con tanta profundidad.

- Viajeros.y.pernoctaciones: indica el tipo de registro (viajeros o pernoctaciones).En este estudio será eliminada ya que no es de interés.

- Residencia..Nivel.1: variable redundante que contiene el valor “Total” en todas sus observaciones; se eliminará del dataset.

- Residencia..Nivel.2: indica el origen de los viajeros, diferenciando entre residentes en España y residentes en el extranjero. En este estudio será eliminada ya que no es de interés.

- Periodo: recoge el año y el mes al que corresponde cada observación.

- Total: valor numérico asociado al tipo de registro (viajeros o pernoctaciones) en el periodo y territorio determinados.

En el momento de la importación, todas las variables se cargaron inicialmente con tipo de dato character. Posteriormente, durante la fase de preparación de los datos, se realizará la conversión de aquellas variables que correspondan a fechas, factores o valores numéricos, con el fin de facilitar su análisis estadístico y gráfico.

Como primer paso del análisis exploratorio, se utilizó la función `glimpse()` (del paquete dplyr) para obtener una visión general de la estructura del dataset.

Gracias a esta función se pudo observar que todas las columnas se importaron como tipo carácter, por lo que será necesario realizar conversiones de tipo en etapas posteriores.

```{r}
df_Turismo %>% glimpse()
```

La columna Total presenta puntos como separadores de miles, por lo que, para garantizar cálculos correctos, se eliminaron.

```{r}
df_Turismo <- df_Turismo %>% mutate(Total = str_replace_all(Total, "\\.", ""))
```

Con el objetivo de revisar el contenido de cada variable y detectar posibles inconsistencias, se aplicó la función `sapply()` combinada con `unique()` al dataframe del turismo.

Esta operación permitió obtener los valores únicos presentes en cada una de las columnas, facilitando la identificación de errores o redundancias en los datos.

A partir de este análisis se obtuvieron las siguientes observaciones:

- Totales.Territoriales presenta un único valor (“Total nacional”), por lo que se confirma que esta variable no aporta información útil y será eliminada.

- Comunidades.y.Ciudades.Autónomas (posteriormente renombrada como CCAA) contiene 20 valores únicos, cuando en realidad existen 19 comunidades y ciudades autónomas, lo que sugiere la posible presencia de algún error o duplicado en los nombres.

- Las variables Periodo y Total no presentan incidencias destacables en esta fase.

Este análisis preliminar permitió detectar columnas redundantes y posibles errores de codificación que deberán corregirse en la fase de limpieza del dataset antes de continuar con el análisis exploratorio.

```{r}
sapply(df_Turismo, function(x) length(unique(x)))
```

Tras analizar los valores únicos, se observó que la variable CCAA presentaba registros vacíos o en blanco, lo que explica las discrepancias detectadas anteriormente.

Estos valores se eliminarán en la fase de limpieza del dataset.

```{r}
print(unique(df_Turismo$Comunidades.y.Ciudades.Autónomas))
```

Se eliminaron las filas correspondientes al total nacional y a las comunidades autónomas, ya que esta información es redundante y puede obtenerse fácilmente a partir del resto de los registros si fuera necesario.

Además, se eliminó la columna Totales.Territoriales y aquellas filas que contenían valores vacíos en la variables CCAA, utilizando las funciones `select()` y `filter()` del paquete `dplyr`.

```{r}
df_Turismo <- df_Turismo %>%
  select(-Totales.Territoriales) %>%
  filter(str_trim(Comunidades.y.Ciudades.Autónomas) != "") %>% 
  arrange(Comunidades.y.Ciudades.Autónomas, Provincias, Periodo)
```

Para simplificar el análisis y la interpretación gráfica, se decidió agrupar la información a nivel de comunidades y ciudades autónomas.

Aunque disponer de datos desagregados por provincia podría resultar interesante para estudios más específicos, en este trabajo se opta por un enfoque autonómico que permite una visión más general y comparativa del turismo en España. Además, como nuestro enfoque va a ser la comparativa entre turismo y ocupación, las variables relativas a la residencia y a los viajeros y pernoctaciones, serán eliminadas.

```{r}
df_Turismo <- df_Turismo %>%
  select(-c(Provincias,Viajeros.y.pernoctaciones,Residencia..Nivel.1,Residencia..Nivel.2))
```

Como se observó en la exploración inicial, todas las columnas se habían importado como tipo carácter, por lo que, para facilitar el análisis temporal, se modificó el tipo de dato de la variable Periodo, convirtiéndola a formato fecha mediante la función `ym()`, tras reemplazar el carácter “M” por un guion con `str_replace()`.

```{r}
df_Turismo <- df_Turismo %>%
  mutate(Periodo = str_replace(Periodo, "M", "-"), 
    Periodo = ym(Periodo))
```

Además, se transformó la columna Total a tipo numérico, ya que contiene los valores cuantitativos asociados al número de viajeros o pernoctaciones. Esta conversión permitirá realizar operaciones estadísticas y cálculos posteriores sin generar errores de tipo de dato.

```{r}
df_Turismo <- df_Turismo %>% 
  mutate(Total=as.numeric(Total))
```

Antes de convertir la variable Comunidades.y.Ciudades.Autónoma a tipo factor, fue necesario limpiar y estandarizar sus valores.

Se eliminaron los números iniciales, espacios y caracteres innecesarios, y se ajustó el formato de texto para unificar la escritura de los nombres de las comunidades. Además, se determinó la variable como tipo factor.

```{r}
df_Turismo <- df_Turismo %>% 
  rename(CCAA = Comunidades.y.Ciudades.Autónomas) %>% 
  mutate(
    CCAA = str_replace(CCAA, "^[0-9]+\\s+", ""),
    CCAA = str_replace(CCAA,"^\\s*([^,]+?)\\s*,\\s*([^,]+?)\\s*$", "\\2 \\1"),
    CCAA = str_squish(CCAA)
  ) %>%
  mutate(CCAA = as.factor(CCAA))
```

Para continuar con el análisis, se creó un nuevo conjunto de datos agregado a nivel de comunidad autónoma.

```{r}
df_Turismo <- df_Turismo %>%
  group_by(CCAA, Periodo) %>% 
  summarise(Total = sum(Total, na.rm = TRUE), .groups = "drop")
```

Dado que inicialmente este dataset contenía espacios en blanco, resulta necesario comprobar que, tras el proceso de limpieza, todos los valores se hayan corregido correctamente. Además, se verifica si existen valores faltantes (NA) en las distintas variables.

```{r}
#Huecos en blanco
sum(df_Turismo == "", na.rm = TRUE)
colSums(df_Turismo == "", na.rm = TRUE)

#NA
anyNA(df_Turismo)
colSums(is.na(df_Turismo))
```

Se confirma que no hay valores faltantes ni espacios en blanco, por lo que el dataset está limpio y listo para el análisis.

Una vez arreglada la base de datos, la guardamos en un fichero Rdata
```{r}
save(df_Turismo, file='Data/df_Turismo.RData')
```


## ANÁLISIS UNIVARIANTE

Como primer paso del análisis univariante, se calcularon los estadísticos descriptivos básicos de las variables incluidas en el dataset mediante la función summary(). 

```{r}
summary(df_Turismo)
```
### ANÁLISIS UNIVARIANTE EXTENDIDO

A continuación, vamos a extender el análisis ya que, al aplicar esta función sobre variables categóricas, no obtenemos información muy relevante a nivel estadístico. Sin embargo, estos estadísticos muestran la frecuencia de cada categoría, confirmando que los datos son coherentes con lo esperado. 

Para comprender con mayor profundidad la variable Total, convendría agruparla en sus diferentes categorías y, analizar entonces sus estadísticos ya que puede ocultar las diferencias existentes entre regiones. Aunque en este caso estamos involucrando dos variables, hemos considerado ponerlo en este apartado, ya que en el analisis bivariante haremos un estudio más profundo sobre relaciones entre las diferentes características.

```{r}
df_Turismo %>%
  group_by(CCAA) %>%
  summarise(
    media = mean(Total, na.rm = TRUE),
    mediana = median(Total, na.rm = TRUE),
    desviacion_tipica = sd(Total, na.rm = TRUE),
    minimo = min(Total, na.rm = TRUE),
    maximo = max(Total, na.rm = TRUE),
    n_observaciones = n()
  ) %>%
  arrange(desc(media)) %>% 
  print()
```
#TODO EXPLICAR ALGO

A continuación se muestran los estadísticos del Total Nacional agrupando todas las comunidades.

```{r}
nacional_mensual <- df_Turismo %>%
  group_by(Periodo) %>%
  summarise(Total = sum(Total, na.rm = TRUE), .groups = "drop")

nacional_mensual %>%
  summarise(
    media = mean(Total, na.rm = TRUE),
    mediana = median(Total, na.rm = TRUE),
    desviacion_tipica = sd(Total, na.rm = TRUE),
    varianza = var(Total, na.rm = TRUE),
    minimo = min(Total, na.rm = TRUE),
    maximo = max(Total, na.rm = TRUE),
    n_observaciones = n()
  )
```
#TODO EXPLICAR

## REPRESENTACIÓN GRÁFICA

Para visualizar mejor estos datos, se emplea una representación gráfica. En primer lugar, se analiza el total nacional, con el objetivo de obtener una visión general de las tendencias y dinámicas estacionales presentes en los datos.

```{r}
ggplot(nacional_mensual, aes(Periodo, Total)) +
  geom_line(linewidth = 0.8) +
  scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
  labs(title = "Serie temporal de viajeros por mes",
       x = "Periodo", y = "Total") +
  theme_minimal()
```
En la gráfica se aprecia una tendencia creciente a lo largo del tiempo y una marcada estacionalidad, factores que se estudiarán con mayor profundidad en apartados posteriores. Además, se observan valores atípicos asociados a la pandemia de la COVID-19, que provocaron una fuerte caída en los registros turísticos.

A continuación, se representa gráficamente la serie temporal correspondiente a cada comunidad y ciudad autónoma, con el objetivo de observar la evolución del turismo en cada territorio y comparar sus comportamientos a lo largo del tiempo.

```{r}
ca_mensual <- df_Turismo %>%
  group_by(CCAA, Periodo) %>%
  summarise(Total = sum(Total, na.rm = TRUE), .groups = "drop")

ggplot(ca_mensual, aes(Periodo, Total)) +
  geom_line(linewidth = 0.6) +
  facet_wrap(~ CCAA, scales = "free_y", ncol = 3) +
  scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
  labs(title = "Serie temporal por Comunidad Autónoma",
       x = "Periodo", y = "Total") +
  theme_minimal()
```

#TODO ESTO ES SEGÚN LO QUE YO HE VISTO EN LOS GRAFICOS, CREO QUE ESTARÁ BIEN PERO REVISAR

En términos generales, todas las comunidades presentan una fuerte estacionalidad, con picos de actividad turística durante los meses de verano.

Sin embargo, al analizar la tendencia a largo plazo, se aprecia que la Comunidad de Madrid, el País Vasco y Canarias muestran una tendencia claramente creciente, lo que indica un aumento sostenido del turismo en estos territorios.
Por el contrario, comunidades como Ceuta presentan una evolución más estacionaria, sin una tendencia ascendente evidente.

También se observan diferencias en la variabilidad de las series: en comunidades como Illes Balears, Asturias, Andalucía o la Comunitat Valenciana se aprecia una heterocedasticidad significativa, es decir, una mayor dispersión de los valores a medida que aumenta el número de turistas. En cambio, en regiones como Madrid o Canarias, la variabilidad parece mantenerse más constante en el tiempo.

Finalmente, en todas las comunidades se detecta un descenso abrupto en 2020, correspondiente al impacto de la pandemia de la COVID-19, que afectó de forma notable a la actividad turística.

En el siguiente apartado, se procederá a detectar de forma más formal estos valores atípicos, aplicando el método de detección 3σ de forma estacional (por mes y comunidad autónoma), lo que permite identificar anomalías reales sin confundir los picos de temporada alta o baja con valores atípicos.

## DETECCIÓN DE OUTLIERS

```{r Regla 3 Sigma}
Sigma3 <- function(x){
  return(abs(x - mean(x)) > 3*sd(x))
}
```


```{r Regla Hampel}
Hampel <- function(x){
  MADM <- 1.4826 * (median(abs(x - median(x))))
  return(x > 3*MADM)
}
```


```{r Regla Percentil}
Percentil_1090 <- function(x){
  q10 <- quantile(x, probs=0.1)
  q90 <- quantile(x, probs=0.9)
  return((x < q10) & (x > q90))
}
```


```{r Regla boxplot}
Boxplot <- function(x){
  inf <- median(x) - IQR(x)
  sup <- median(x) + IQR(x)
  return((x < inf) | (x > sup))
}
```

```{r}
ca_mensual <- df_Turismo %>%
  group_by(CCAA, Periodo) %>%
  summarise(Total = sum(Total, na.rm = TRUE), .groups = "drop") %>%
  mutate(Mes = month(Periodo, label = TRUE, abbr = TRUE))

outliers_estacionales <- ca_mensual %>%
  group_by(CCAA, Mes) %>%
  mutate(
    media_mes = mean(Total, na.rm = TRUE),
    sd_mes = sd(Total, na.rm = TRUE),
    upLim_mes = media_mes + 3 * sd_mes,
    lowLim_mes = media_mes - 3 * sd_mes,
    es_outlier = ifelse(Total < lowLim_mes | Total > upLim_mes, TRUE, FALSE)
  ) %>%
  ungroup()

resumen_out_estacional <- outliers_estacionales %>%
  group_by(CCAA) %>%
  summarise(
    n_outliers = sum(es_outlier, na.rm = TRUE),
    prop_outliers = mean(es_outlier, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(n_outliers))

resumen_out_estacional

```

Se observa que las comunidades con mayor número de outliers son Castilla-La Mancha, Comunitat Valenciana y La Rioja, con entre 10 y 11 observaciones atípicas cada una. En general, estas comunidades presentan una mayor variabilidad mensual, lo que puede estar asociado a fluctuaciones puntuales en el turismo o a posibles registros anómalos en los datos.

En el extremo opuesto, comunidades como Canarias, Comunidad de Madrid, País Vasco y Navarra no presentan valores atípicos detectables bajo este método, lo que indica una mayor estabilidad temporal en sus series turísticas.

En términos relativos, la proporción de outliers es reducida en todos los casos (inferior al 4%), lo que sugiere que el conjunto de datos es coherente y sin grandes anomalías, más allá de los valores excepcionales ya identificados durante la pandemia de la COVID-19.

A modo de ejemplo, se representa gráficamente la detección de valores atípicos en el caso de Illes Balears, una comunidad que presenta una alta dispersión entre meses y permite comprobar la correcta aplicación del método 3σ estacional, y en la Comunitat Valenciana, una de las regiones con mayor número de outliers.

En ambos casos, se observa que la gran mayoría de los valores atípicos corresponden al periodo de la pandemia de la COVID-19, lo que confirma las anomalías ya detectadas previamente en la serie temporal nacional y autonómica.

```{r}
outliers_estacionales %>%
  filter(CCAA == "Illes Balears") %>%
  ggplot(aes(Periodo, Total)) +
  geom_line(color = "grey60") +
  geom_point(aes(color = es_outlier), size = 1.5) +
  scale_color_manual(values = c("FALSE" = "black", "TRUE" = "red")) +
  labs(
    title = "Detección de valores atípicos estacionales (3σ) - Islas Baleares",
    x = "Periodo", y = "Total", color = "Outlier"
  ) +
  theme_minimal()

outliers_estacionales %>%
  filter(CCAA == "Comunitat Valenciana") %>%
  ggplot(aes(Periodo, Total)) +
  geom_line(color = "grey60") +
  geom_point(aes(color = es_outlier), size = 1.5) +
  scale_color_manual(values = c("FALSE" = "black", "TRUE" = "red")) +
  labs(
    title = "Detección de valores atípicos estacionales (3σ) - Comunidad Valenciana",
    x = "Periodo", y = "Total", color = "Outlier"
  ) +
  theme_minimal()
```

# IMPUTACIÓN DE OUTLIERS

```{r Inicialización de las variables}
# Hay que convertir los datos a una serie temporal de la librería forecast, dado que hay que hacerlo para cada CC.AA. mejor hacer una función
Convertir_en_Serie <- function(vector, Anio_Inicio, Mes_Inicio, Anio_Final, Mes_Final, frec){
  return(ts(vector, start = c(Anio_Inicio, Mes_Inicio), end = c(Anio_Final, Mes_Final), frequency = frec))
}
```


### Análisis clásico

```{r Función para el análisis clásico}
Diferencias <- function(serie){
  return(serie[2:length(serie)] - serie[1:(length(serie) - 1)])
}
Cocientes <- function(serie){
  return(serie[2:length(serie)] / serie[1:(length(serie) - 1)])
}
CV <- function(serie){
  stopifnot(is.ts(serie))
  return(sd(serie, na.rm=T) / mean(serie, na.rm=T))
}

Analisis_Clasico <- function(Serie){
  # Calculo de la componente tendencial
  Tendencia <- forecast::ma(Serie, order = frequency(Serie), centre = TRUE)
  # Hay que ver si tomamos el esquema aditivo o multiplicativo
  if ( CV(Diferencias(Serie)) < CV(Cocientes(Serie)) ){
    # En este caso el modelo debe ser aditivo
    Serie_Sin_Tendencia <- Serie - Tendencia
    Medias_Est <- tapply(Serie_Sin_Tendencia, cycle(Serie_Sin_Tendencia), mean, na.rm = TRUE)
    Medias_Est <- Medias_Est - mean(Medias_Est)
    Estacional <- ts(rep(Medias_Est, length.out = length(Serie)),
                 start = start(Serie), frequency = frequency(Serie))
    Ruido <- Serie_Sin_Tendencia - Estacional
    return(list(type = "Aditivo", trend = Tendencia, seasonal = Estacional,
       remainder = Ruido, fitted = Tendencia + Estacional))
    
  } else {
    # El caso contrario será multiplicativo
    Serie_Sin_Tendencia <- Serie / Tendencia
    Medias_Est <- tapply(Serie_Sin_Tendencia, cycle(Serie_Sin_Tendencia), mean, na.rm = TRUE)
    Medias_Est <- Medias_Est / mean(Medias_Est)
    Estacional <- ts(rep(Medias_Est, length.out = length(Serie)),
                 start = start(Serie), frequency = frequency(Serie))
    Ruido <- Serie_Sin_Tendencia / Estacional
    return(list(type = "Multiplicativo", trend = Tendencia, seasonal = Estacional,
       remainder = Ruido, fitted = Tendencia * Estacional))
  }
}
```

Haremos una función para conocer los errores de los modelos

```{r Errores}
Errores <- function(Serie, Predic){
  rmse <- sqrt(mean((Serie - Predic)^2))
  mape <- 100*mean(abs(Serie - Predic) / Serie)
  return(list(rmse = rmse, mape = mape))
}
```

También es necesario hacer predicciones y ver la calidad de estas. La idea es hacer un ARIMA.

```{r Predicciones}
Prediccion <- function(Serie, Serie_Completa, H){
  Modelo <- auto.arima(Serie, stepwise=FALSE, approximation=FALSE)
  pred <- forecast(Modelo, h=H)
  
  df_forecast <- data.frame(
  tiempo = as.numeric(time(pred$mean)),
  valor = as.numeric(pred$mean),
  tipo = "Prediccion")
  
  df_serie1 <- data.frame(
  tiempo = as.numeric(time(Serie_Completa)[1:(length(Serie_Completa)-H)]),
  valor = as.numeric(Serie_Completa[1:(length(Serie_Completa)-H)]),
  tipo = "Serie")
  
  df_serie2 <- data.frame(
  tiempo = as.numeric(time(Serie_Completa)[(length(Serie_Completa)-H):length(Serie_Completa)]),
  valor = as.numeric(Serie_Completa[(length(Serie_Completa)-H):length(Serie_Completa)]),
  tipo = "Serie")
  
  df_ajuste <- data.frame(
  tiempo = as.numeric(time(Serie)),
  valor = as.numeric(Serie - residuals(Modelo)),
  tipo = "Ajuste")
  
  df1 <- bind_rows(df_serie1, df_ajuste)
  df2 <- bind_rows(df_serie2, df_forecast)
  
  grafica_Ajuste <- ggplot(df1, aes(x = tiempo, y = valor, color = tipo)) + 
    geom_line(size = 1) +
    labs(title = "Gráfica de ajuste")
  
  grafica_Prediccion <- ggplot(df2, aes(x = tiempo, y = valor, color = tipo)) + 
    geom_line(size = 1) +
    labs(title = "Gráfica de predicción")
  
  return(list(Prediccion=pred, 
              Grafica_Ajuste=grafica_Ajuste, 
              Grafica_Predic=grafica_Prediccion))
}
```

Llamamos a las funciones creadas ara hacer el análisis
```{r}
df_Turismo %>% 
  group_by(CCAA)
  Convertir_en_Serie
```


## OCUPACIÓN

El segundo conjunto de datos corresponde a la ocupación por sectores económicos en España, obtenido del INE.Recoge el número de personas ocupadas (en miles) por comunidad o ciudad autónoma, sector y periodo trimestral.

Las variables incluidas son:

- Sexo: presenta un valor 'mujer', 'hombre' y 'Ambos sexos'). POsteriormente se eliminará porque no nos interesa.

- Comunidades.y.Ciudades.Autónomas (CCAA): incluye las distintas comunidades y el total nacional, que también se eliminará por ser redundante.

- Sector.económico: distingue cuatro sectores: agricultura, industria, construcción y servicios. En este caso, nos centraremos en el sector servicios, ya que es el que está estrechamente relacionado con el turismo.

- Periodo: año y trimestre.

- Total: número de personas ocupadas en miles.#TODO SI AQUI ESTAN EXPRESADOS EN MILES Y ALLI DIRECTAMENTE DEBEMOS ESTANDARIZARLO

Este dataset permitirá analizar la evolución del empleo por sectores y regiones, así como su relación con la actividad turística.

Como primer paso, se utilizó la función glimpse() para revisar la estructura del dataset.

Se comprobó que todas las columnas se importaron como tipo carácter, por lo que será necesario ajustar los tipos de datos en los siguientes pasos.

```{r}
df_Ocupacion %>% glimpse()
```

Para limpiar y preparar la base de datos de ocupación, ha sido necesario realizar los siguientes pasos:

1. Eliminar la columna “Sexo”.

2. Eliminar números y carácteres especiales de los nombres de las comunidades. Además de filtrar y eliminar el valor “Total nacional” de la variable CCAA, por ser redundante respecto al resto de comunidades y ciudades autónomas. Posteriormente, esta variable se convierte a tipo factor.

3. Filtrar los registros correspondientes al sector “Servicios” dentro de la columna Sector.económico. Dado que la tabla se centrará exclusivamente en este sector, la variable se elimina por resultar redundante.

4. Convertir la variable “Periodo” del formato YYYYTQ (por ejemplo, 2022T3) a un formato de fecha trimestral mediante la función `as.yearqtr()`.

5. Normalizar la variable “Total”, eliminando la palabra “miles” y los puntos de millares, sustituyendo la coma decimal por punto, convirtiendo los valores a numéricos y multiplicándolos por 1.000 para expresarlos en personas. De este modo, se mantiene la coherencia de escala con la base de datos de turismo.

```{r}
df_Ocupacion_clean <-  df_Ocupacion %>% 
  #1
  filter(Sexo == "Ambos sexos") %>% 
  select(-Sexo) %>%
  #2
  rename(CCAA=Comunidades.y.Ciudades.Autónomas) %>% 
  mutate(CCAA = str_replace(CCAA, "^[0-9]+\\s+", ""), 
  CCAA = str_replace(CCAA, "^\\s*([^,]+?)\\s*,\\s*([^,]+?)\\s*$", "\\2 \\1")) %>%
  filter(CCAA != "Total Nacional") %>%
  mutate(CCAA=as.factor(CCAA)) %>% 
  #3
  filter(Sector.económico=='Servicios') %>% 
  select(-Sector.económico) %>% 
  #4 
  mutate(Periodo = str_replace(Periodo, "T", "-"), 
    Periodo = as.yearqtr(Periodo)) %>% 
  #5
  mutate(
    Total=str_replace_all(Total, '\\.',""),
    Total = str_replace(Total, ",", "."),
    Total = as.numeric(Total)*1000 
  ) %>% 
  arrange(CCAA, Periodo)
```

#TODO LAS FECHAS EN FORMATO YM MUESTRAN DIA PERO AQUI SON TRIMESTRES QUE HACEMOS

```{r}
# Total nacional por trimestre
ocup_nacional <- df_Ocupacion_clean %>%
  group_by(Periodo) %>%
  summarise(Total = sum(Total, na.rm = TRUE), .groups = "drop")

ggplot(ocup_nacional, aes(Periodo, Total)) +
  geom_line(linewidth = 0.8) +
  scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
  labs(title = "Serie temporal de ocupación (sector servicios) — Total nacional (trimestral)",
       x = "Periodo", y = "Personas ocupadas") +
  theme_minimal()
```
#TODO EXPLICAR

```{r}
ocup_ccaa <- df_Ocupacion_clean %>%
  group_by(CCAA, Periodo) %>%
  summarise(Total = sum(Total, na.rm = TRUE), .groups = "drop")

ggplot(ocup_ccaa, aes(Periodo, Total)) +
  geom_line(linewidth = 0.5) +
  facet_wrap(~ CCAA, scales = "free_y", ncol = 3) +
  scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
  labs(title = "Ocupación en el sector servicios por Comunidad Autónoma (trimestral)",
       x = "Periodo", y = "Personas ocupadas") +
  theme_minimal() +
  theme(panel.spacing = unit(1, "lines"),
        strip.text = element_text(size = 9))

```
#TODO EXPLICAR

```{r}
ocup_ccaa_q <- ocup_ccaa %>%
  mutate(Trimestre = factor(quarter(as.Date(Periodo)), levels = 1:4,
                            labels = c("Q1","Q2","Q3","Q4")))

outliers_q <- ocup_ccaa_q %>%
  group_by(CCAA, Trimestre) %>%
  mutate(
    media_q = mean(Total, na.rm = TRUE),
    sd_q    = sd(Total, na.rm = TRUE),
    upLim_q = media_q + 3 * sd_q,
    lowLim_q= media_q - 3 * sd_q,
    es_outlier = Total < lowLim_q | Total > upLim_q
  ) %>%
  ungroup()

resumen_out_q <- outliers_q %>%
  group_by(CCAA) %>%
  summarise(
    n_outliers   = sum(es_outlier, na.rm = TRUE),
    prop_outliers= mean(es_outlier, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(n_outliers))

resumen_out_q

```

#TODO EXPLICAR

## LIMPIEZA PARA MERGE

#TODO EXPLICAR

```{r}
turismo_to_merge <- df_Turismo %>%
  mutate(Periodo = as.yearqtr(Periodo)) %>%
  group_by(CCAA, Periodo) %>%
  summarise(Total_turismo = sum(Total, na.rm = TRUE), .groups = "drop") %>% 
  arrange(CCAA, Periodo)
```

#TODO EXPLICAR

```{r}
df_Turismo_Ocupacion <- merge(
  x = turismo_to_merge,
  y = (df_Ocupacion_clean %>% 
    rename(Numero_ocupados = Total)),
  by.x = c("CCAA", "Periodo"),
  by.y = c("CCAA", "Periodo"))
```

Una vez arreglada la base de datos, la guardamos en un fichero Rdata
```{r}
save(df_Turismo_Ocupacion, file='Data/df_Turismo_Ocupacion.RData')
```

Ahora vamos a hacer un grafico de dispersion que relacione las variables del nuevo data frame Turismo-NOcupados.

```{r}
# Crear una carpeta donde guardar los gráficos
dir.create("graficos_comunidades", showWarnings = FALSE)

# Obtener todas las comunidades únicas
comunidades <- unique(df_Turismo_Ocupacion$CCAA)

# Bucle para crear un gráfico por comunidad
for (com in comunidades) {
  
  # Filtrar datos de la comunidad actual
  datos_com <- df_Turismo_Ocupacion %>%
    filter(CCAA == com)
  
  # Crear el gráfico
  p <- ggplot(datos_com, aes(x = Total_turismo, y = Numero_ocupados)) +
    geom_point(color = "#0072B2", alpha = 0.7) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linewidth = 0.8) + # línea de tendencia
    labs(
      title = paste("Relación entre Turismo y Ocupación -", com),
      x = "Total Turismo",
      y = "Número de Ocupados (Servicios)"
    ) +
    theme_minimal()
  
  # Mostrar el gráfico (opcional)
  print(p)
  
  # Guardar el gráfico como archivo PNG
  ggsave(filename = paste0("graficos_comunidades/", gsub(" ", "_", com), ".png"),
         plot = p, width = 7, height = 5)
}

```


Cálculo de correlaciones de cada comunidad entre el numero de ocupados y el total del turismo
```{r}
correlaciones_por_comunidad <- df_Turismo_Ocupacion %>%
  group_by(CCAA) %>%
  summarise(
    resultado = list(cor.test(Total_turismo, Numero_ocupados, method = "pearson"))
  ) %>%
  mutate(
    correlacion = map_dbl(resultado, "estimate"),
    p_value = map_dbl(resultado, "p.value")
  ) %>%
  select(CCAA, correlacion, p_value) %>%
  arrange(desc(correlacion))

correlaciones_por_comunidad
```


