---
title: "Limpieza_Datos"
author: "Iyán Álvarez, Azahara Martínez, Juan Alcaraz Otón"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Librerias}
library(lubridate)
library(tidyr)
library(tidyverse)
library(scales)
```

# IMPORTACIÓN

Para el desarrollo del análisis, se han utilizado dos bases de datos principales. La primera contiene información relacionada con el turismo en España, desglosada por comunidades autónomas y provincias, e incluye variables como el número de viajeros y pernoctaciones registradas a lo largo de varios años. La segunda base de datos corresponde al sector servicios, específicamente a la ocupación en dicho sector, que se analizará posteriormente para establecer relaciones con la evolución del turismo.

Con el fin de garantizar que los datos utilizados estén siempre actualizados, se ha optado por realizar la importación directamente desde la URL de origen, en lugar de utilizar copias locales. De este modo, si los archivos son modificados o actualizados en la fuente oficial, el código podrá acceder automáticamente a la versión más reciente.

```{r Enlaces de descarga}
url_ocupacion<-"https://www.ine.es/jaxiT3/files/t/es/csv_bdsc/65311.csv?nocab=1"
url_turismo<-"https://www.ine.es/jaxiT3/files/t/es/csv_bdsc/67190.csv?nocab=1"
```

Antes de proceder a la carga definitiva, se ha comprobado la codificación (encoding) de cada archivo, con el objetivo de evitar posibles problemas de lectura o visualización de caracteres especiales en las tablas. Esto se ha realizado aplicando la función correspondiente para identificar el tipo de codificación de cada dataset.

```{r Codificación de los archivos}
guess_encoding(url_turismo)
guess_encoding(url_ocupacion)
```

Finalmente, los datos se han importado utilizando la función read_csv(), creando dos dataframes principales:

```{r Importación}
df_Turismo <- read.csv(url_turismo,
                       header = TRUE,
                       sep = ";",
                       encoding = "UTF-8")

df_Ocupacion <- read.csv(url_ocupacion,
                       header = TRUE,
                       sep = ";",
                       encoding = "UTF-8")
```

# CARACTERÍSTICAS GENERALES

## TURISMO

Una vez importados los datos, se procede al análisis de las características generales del primer conjunto, correspondiente al turismo en España. Este dataset recopila información sobre el número de viajeros y las pernoctaciones registradas a lo largo del tiempo, desglosadas por comunidades y provincias.

Las variables incluidas son las siguientes:

- Totales.Territoriales: columna con un único valor (“Total Nacional”). No aporta información relevante para el análisis, por lo que se eliminará en fases posteriores.

- Comunidades.y.Ciudades.Autónomas: identifica la comunidad o ciudad autónoma correspondiente a cada registro.

- Provincias: especifica la provincia asociada a cada comunidad.

- Viajeros.y.pernoctaciones: indica el tipo de registro (viajeros o pernoctaciones).

- Residencia..Nivel.1: variable redundante que contiene el valor “Total” en todas sus observaciones; se eliminará del dataset.

- Residencia..Nivel.2: indica el origen de los viajeros, diferenciando entre residentes en España y residentes en el extranjero.

- Periodo: recoge el año y el mes al que corresponde cada observación.

- Total: valor numérico asociado al tipo de registro (viajeros o pernoctaciones) en el periodo y territorio determinados.

En el momento de la importación, todas las variables se cargaron inicialmente con tipo de dato character. Posteriormente, durante la fase de preparación de los datos, se realizará la conversión de aquellas variables que correspondan a fechas, factores o valores numéricos, con el fin de facilitar su análisis estadístico y gráfico.

Como primer paso del análisis exploratorio, se utilizó la función glimpse() (del paquete dplyr) para obtener una visión general de la estructura del dataset.
Gracias a esta función se pudo observar que todas las columnas se importaron como tipo carácter, por lo que será necesario realizar conversiones de tipo en etapas posteriores.

```{r}
df_Turismo %>% glimpse()
```
Vemos que los puntos en la columna del total nos podrían causar problemas de comprensión de los datos por parte de R(que no entienda bien que significa el .) #TODO EXPLICAR BIEN

```{r}
df_Turismo <- mutate(df_Turismo, Total = str_replace_all(Total, "\\.", ""))
```

Con el objetivo de revisar el contenido de cada variable y detectar posibles inconsistencias, se aplicó la función sapply() combinada con unique() al dataframe del turismo.
Esta operación permitió obtener los valores únicos presentes en cada una de las columnas, facilitando la identificación de errores o redundancias en los datos.

A partir de este análisis se obtuvieron las siguientes observaciones:

- Totales.Territoriales presenta un único valor (“Total nacional”), por lo que se confirma que esta variable no aporta información útil y será eliminada.

- Comunidades.y.Ciudades.Autónomas contiene 20 valores únicos, cuando en realidad existen 19 comunidades y ciudades autónomas, lo que sugiere la posible presencia de algún error o duplicado en los nombres.

- Provincias muestra 51 valores únicos, aunque en España existen 50 provincias, por lo que también será necesario revisar esta variable.

- Viajeros.y.Pernoctaciones incluye correctamente 2 valores distintos, lo que confirma su coherencia.

- Residencia..Nivel.1 tiene un único valor (“Total”), por lo que se considera redundante.

- Residencia..Nivel.2 presenta 3 valores únicos, cuando solo deberían existir 2 categorías (residentes en España y residentes en el extranjero), lo que indica un posible error en la codificación de algunos registros.

- Las variables Periodo y Total no presentan incidencias destacables en esta fase.

Este análisis preliminar permitió detectar columnas redundantes y posibles errores de codificación que deberán corregirse en la fase de limpieza del dataset antes de continuar con el análisis exploratorio.

```{r}
sapply(df_Turismo, function(x) length(unique(x)))
```
Tras analizar los valores únicos, se observó que las variables Comunidades.y.Ciudades.Autónomas, Provincias y Residencia2.Nivel.2 presentaban registros vacíos o en blanco, lo que explica las discrepancias detectadas anteriormente.
Estos valores se eliminarán en la fase de limpieza del dataset.

```{r}
print(unique(df_Turismo$Comunidades.y.Ciudades.Autónomas))
print(unique(df_Turismo$Residencia..Nivel.2))
```
Se eliminaron las filas correspondientes al total nacional y a las comunidades autónomas, ya que esta información es redundante y puede obtenerse fácilmente a partir del resto de los registros si fuera necesario.

Además, se eliminó la columna Totales.Territoriales y aquellas filas que contenían valores vacíos en las variables Comunidades.y.Ciudades.Autónomas y Provincias, utilizando las funciones select() y filter() del paquete dplyr.

```{r}
df_Turismo <- df_Turismo %>%
  select(-Totales.Territoriales) %>%
  filter(str_trim(Comunidades.y.Ciudades.Autónomas) != "")

df_Turismo <- df_Turismo %>%
  select(-Provincias)
```

Como ya se ha mencionado, la columna Residencia..Nivel.1 contiene un único valor (“Total”) en todas sus observaciones, por lo que no aporta información relevante al análisis.

Se decidió eliminarla junto con las filas vacías de la variable Residencia..Nivel.2.

```{r}
unique(df_Turismo$Residencia..Nivel.1)

df_Turismo <- df_Turismo %>% 
  select(-Residencia..Nivel.1) %>% 
  filter(str_trim(Residencia..Nivel.2) != "")
```
Creo el data set agregado por cominidades autónomas

```{r}
df_Turismo <- df_Turismo %>%
  group_by(Comunidades.y.Ciudades.Autónomas, Periodo, Viajeros.y.pernoctaciones, Residencia..Nivel.2)
```

Como se observó en la exploración inicial, todas las columnas se habían importado como tipo carácter.
Para facilitar el análisis temporal, se modificó el tipo de dato de la variable Periodo, convirtiéndola a formato fecha mediante la función as.yearmon() (paquete zoo), tras reemplazar el carácter “M” por un guion con str_replace().

```{r}
df_Turismo <- df_Turismo %>%
  mutate(Periodo = str_replace(Periodo, "M", "-"), 
    Periodo = ym(Periodo))
```

A continuación, se convirtieron a tipo factor las variables Viajeros.y.pernoctaciones y Residencia..Nivel.2 (renombrada como Residencia), ya que representan categorías con un número limitado de valores posibles.

Transformarlas en factores permite optimizar el uso de memoria, facilitar la agrupación y el filtrado de datos y mejorar la interpretación en análisis estadísticos y representaciones gráficas.

```{r}
df_Turismo <- df_Turismo %>% 
  mutate(Viajeros.y.pernoctaciones=as.factor(Viajeros.y.pernoctaciones)) %>% 
  mutate(Residencia..Nivel.2=as.factor(Residencia..Nivel.2)) %>%
  rename(Residencia=Residencia..Nivel.2)

```

Además, se transformó la columna Total a tipo numérico, ya que contiene los valores cuantitativos asociados al número de viajeros o pernoctaciones.
Esta conversión permitirá realizar operaciones estadísticas y cálculos posteriores sin generar errores de tipo de dato.

```{r}
df_Turismo <- df_Turismo %>% 
  mutate(Total=as.numeric(Total))
```

Antes de convertir las variables Comunidades.y.Ciudades.Autónomas y Provincias (renombrada como Región) a tipo factor, fue necesario limpiar y estandarizar sus valores.

Se eliminaron los números iniciales, espacios y caracteres innecesarios, y se ajustó el formato de texto para unificar la escritura de los nombres de comunidades y provincias.
Esta limpieza garantiza la consistencia de los datos geográficos y evita duplicados derivados de diferencias en el formato.

```{r}
df_Turismo <- df_Turismo %>% 
  mutate(
    Comunidades.y.Ciudades.Autónomas = str_replace(Comunidades.y.Ciudades.Autónomas, "^[0-9]+\\s+", ""),
    Comunidades.y.Ciudades.Autónomas = str_replace(Comunidades.y.Ciudades.Autónomas,
                                                   "^\\s*([^,]+?)\\s*,\\s*([^,]+?)\\s*$", "\\2 \\1"),
    Comunidades.y.Ciudades.Autónomas = str_squish(Comunidades.y.Ciudades.Autónomas)
  ) %>%
  mutate(Comunidades.y.Ciudades.Autónomas = as.factor(Comunidades.y.Ciudades.Autónomas))
```

Una vez limpiados y normalizados los nombres, las variables Comunidades.y.Ciudades.Autónomas y Región se transformaron a tipo factor.

De esta forma, se facilita su uso en agrupaciones, resúmenes estadísticos y representaciones gráficas, además de optimizar el tratamiento de estas variables categóricas en los análisis posteriores.

```{r}
df_Turismo <- df_Turismo %>%
  mutate(Comunidades.y.Ciudades.Autónomas = as.factor(Comunidades.y.Ciudades.Autónomas))
```

## ANÁLISIS UNIVARIANTE

Estadisticos descriptivos. Para las variables de tipo factor hacemos un summary y ya (DESCRIBIR) Aunque no aporten mucho a nivel estadistico, tiene sentido lo que vemos en relacion cn lo que esperamos del datframe.

```{r}
summary(df_Turismo)
```

Sin embargo, de la variable numérica si que podemos hacer algun que otro analisis #TODO completar con algo más exploratorio

```{r}
sd(df_Turismo$Total)
```

Esta sd indica que............

Cobsideramos que analizar todos los datos de esta forma nos hace perder bastante información relativa a cada comunidad autónoma.  Agrupamos comunidades y calculamos nuevos estadisticos.

```{r}
df_Turismo %>%
  group_by(Comunidades.y.Ciudades.Autónomas) %>%
  summarise(
    media = mean(Total, na.rm = TRUE),
    mediana = median(Total, na.rm = TRUE),
    desviacion_tipica = sd(Total, na.rm = TRUE),
    minimo = min(Total, na.rm = TRUE),
    maximo = max(Total, na.rm = TRUE),
    n_observaciones = n()
  ) %>%
  arrange(desc(media)) %>% 
  print()
```

## REPRESENTACIÓN GRÁFICA

Para visualizar mejor estos datos, podemos usar un gráfico. En primer lugar vamos a examinar el total nacional de los datos, para generar una visión general sobre tendencias y dinámicas estacionales. 

Podemos ver que en los datos hay una tendencia creciente y una clara estacionalidad, factores que después analizaremos con mayor profundidad. Además también se observan valores atípicos relacionados con la pandemia del COVID-19.

```{r}
nacional_mensual <- df_Turismo %>%
  group_by(Periodo) %>%
  summarise(Total = sum(Total, na.rm = TRUE), .groups = "drop")

ggplot(nacional_mensual, aes(Periodo, Total)) +
  geom_line(linewidth = 0.8) +
  scale_y_continuous(labels = label_comma(big.mark = ".")) +
  labs(title = "Serie temporal de viajeros y pernoctaciones españolas por mes",
       x = "Periodo", y = "Total",
       color = "Tipo") +
  theme_minimal()
```

Ahora representaremos las CCAA.

```{r}
ca_mensual <- df_Turismo %>%
  group_by(Comunidades.y.Ciudades.Autónomas, Periodo) %>%
  summarise(Total = sum(Total, na.rm = TRUE), .groups = "drop")

ggplot(ca_mensual, aes(Periodo, Total)) +
  geom_line(linewidth = 0.6) +
  facet_wrap(~ Comunidades.y.Ciudades.Autónomas, scales = "free_y", ncol = 3) +
  scale_y_continuous(labels = label_comma(big.mark = ".")) +
  labs(title = "Serie temporal por Comunidad Autónoma",
       x = "Periodo", y = "Total") +
  theme_minimal()
```

Ahora vamos a representar graficamente las 5 provincias con más turismo y las 5 con menos, para ver que más o menos siguen las mismas tendencias que las comunidades autónomas.

Se observa que las que tienen un volumen menor de turismo no presentan la tendencia creciente de las demás provincias. Sin embargo, en las provincias que hay más turismo, la tendencía se acentúa aún más que lo que se puede ver en el total nacional. Estas observaciones también son extrapolables a los datos de las comunidades autónomas.

Algo destacable es la gran dispersión que presenta el gráfico de las Islas Baleares, la cual tiene mucho sentido con los estadísticos univariantes antes extraidos, ya que se observaba una media muy alta pero una mediana mucho más baja, en contraposición por ejemplo con Madrid, que tenía valores más parecidos, y como podemos ver,  tiene una dispersión mucho menor.

Además se observa en todos los gráficos que hemos analizado el valor atípico relativo al COVID-19. A continuación vamos a detectarlo de manera más formal. 
Dado que la serie temporal presenta una marcada estacionalidad, se aplicó el método de detección de valores atípicos 3σ de forma estacional, es decir, calculando la media y la desviación típica por mes y por provincia.
Este enfoque permite comparar cada observación con el comportamiento esperado para esa época del año, evitando identificar como atípicos los picos de temporada alta o las caídas de temporada baja.
Los resultados ofrecen una detección más precisa de anomalías reales o posibles errores en los datos.

```{r}
ca_mensual <- df_Turismo %>%
  group_by(Comunidades.y.Ciudades.Autónomas, Periodo) %>%
  summarise(Total = sum(Total, na.rm = TRUE), .groups = "drop") %>%
  mutate(Mes = month(Periodo, label = TRUE, abbr = TRUE))

outliers_estacionales <- ca_mensual %>%
  group_by(Comunidades.y.Ciudades.Autónomas, Mes) %>%
  mutate(
    media_mes = mean(Total, na.rm = TRUE),
    sd_mes = sd(Total, na.rm = TRUE),
    upLim_mes = media_mes + 3 * sd_mes,
    lowLim_mes = media_mes - 3 * sd_mes,
    es_outlier = ifelse(Total < lowLim_mes | Total > upLim_mes, TRUE, FALSE)
  ) %>%
  ungroup()

resumen_out_estacional <- outliers_estacionales %>%
  group_by(Comunidades.y.Ciudades.Autónomas) %>%
  summarise(
    n_outliers = sum(es_outlier, na.rm = TRUE),
    prop_outliers = mean(es_outlier, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(n_outliers))

resumen_out_estacional

```

Por ejemplo vamos a ver la representación gráfica de los outliers en el caso de Islas Baleares (provincia con alta dispersión entre meses, comprobamos que se aplica bien el 3σ estacional) y Alicante (provincia con mayor cantidad de outliers). Vemos que la gran mayoría de los valores atípicos, como ya habíamos intuido con anterioridad corresponden al periodo relativo al COVID-19.
```{r}
outliers_estacionales %>%
  filter(Comunidades.y.Ciudades.Autónomas == "Illes Balears") %>%
  ggplot(aes(Periodo, Total)) +
  geom_line(color = "grey60") +
  geom_point(aes(color = es_outlier), size = 1.5) +
  scale_color_manual(values = c("FALSE" = "black", "TRUE" = "red")) +
  labs(
    title = "Detección de valores atípicos estacionales (3σ) - Illes Balears",
    x = "Periodo", y = "Total", color = "Outlier"
  ) +
  theme_minimal()

outliers_estacionales %>%
  filter(Comunidades.y.Ciudades.Autónomas == "Comunitat Valenciana") %>%
  ggplot(aes(Periodo, Total)) +
  geom_line(color = "grey60") +
  geom_point(aes(color = es_outlier), size = 1.5) +
  scale_color_manual(values = c("FALSE" = "black", "TRUE" = "red")) +
  labs(
    title = "Detección de valores atípicos estacionales (3σ) - Comunitat Valenciana",
    x = "Periodo", y = "Total", color = "Outlier"
  ) +
  theme_minimal()
```


Como inicialmente en este dataset habian espacios en blanco, vamos a revisar que, una vez todo limpio, debemos comprbar si efectivamente ha quedado todo bien. También comprobamos si hay algún NA

```{r}
#NA
anyNA(df_Turismo)
colSums(is.na(df_Turismo))
```

Se observa que no hay ningun NA

```{r}
#Huecos en blanco
sum(df_Turismo == "", na.rm = TRUE)
colSums(df_Turismo == "", na.rm = TRUE)
```
Tampoco se observan huecos en blanco, por lo que el dataset está limpio.

## OCUPACIÓN

```{r}
df_Ocupacion %>% glimpse()
```


# LIMPIEZA BASE DE DATOS 

##TURISMO 

Ahora voy a toquetear las fechas

```{r}
df_Turismo <- df_Turismo%>%
  separate(col=Periodo,into=c('Año', 'Mes'), sep='M')

df_Turismo <- df_Turismo %>%
  mutate(fecha = ym(paste0(Año, "-", Mes)))
```

## OCUPACIÓN

```{r}
df_Ocupacion_clean <- df_Ocupacion %>%
  dplyr::filter(Comunidades.y.Ciudades.Autónomas != "Total Nacional") %>% #elimino los totales pq son redundantes
  dplyr::filter(Sector.económico == "Servicios") %>% #filtro para quedarme solo con el sector servicios que es el que me interesa
  mutate(Comunidades.y.Ciudades.Autónomas = str_replace(Comunidades.y.Ciudades.Autónomas, "^[0-9]+\\s+", "")) %>%#elimino la enumeracion de los nombres de las comunidades
  select(-Sexo, -Sector.económico) %>% 
  mutate(Periodo = as.yearqtr(str_replace(Periodo, "T", "-"))) %>%
  rename('Comunidades Autónomas'= Comunidades.y.Ciudades.Autónomas)

```

Para tener una imagen general de como se mueve la ocupación
```{r}

```

1. Identificar variables de entrada 
2. Analisis univariante
3. Análisis bivariante
4. Transformacion de variables
5. Obtención de nuevas variables a partir de las originales
