---
title: "Series de tiempo"
author: "Juan Alcaraz Otón"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## SERIES DE TIEMPO

La idea es que en ese documento se haga el análisis de series temporales de los datos, dado que todos los datos que se manejan se prestan a ello.

Como los datos son desconocidos será necesario hacer diferentes pruebas para ver qué modelos son más adecuados para el análisis y predicción de cada serie, entonces esas pruebas se harán en el presente documento y los resultados definitivos se expondrán en el documento final del trabajo.

## Análisis de los datos de ocupación

El análisis de los datos de ocupación se agrupará por CC.AA. debido a que hacerlo por provincias sería extremadamente extenso y costoso, además que no se podrían exponer todos los resultados correctamente.

El interés principal para usar las técnicas de análisis de series temporales es la imputación de datos y eliminación de _outliers_. Como es bien sabido, entre los años $2019$ y $2023$ aproximadamente, se produjo una pandemia mundial de _Covid-19_, la cual obligó a mucho países, incluyendo España a imponer importantes restricciones de movilidad tanto a los ciudadanos españoles como los extranjeros. Esto se ve claramente reflejado en los datos de ocupación.

La pregunta principal es si esos datos, pertenecientes a los años de la pandemia, deben interpretarse como _outliers_ o no, y más aún si deberían tenerse en cuenta u obviarse.

También se plantea la pregunta de cómo afectó la pandemia a la tendencia de crecimiento que venía experimentando la ocupación.

Otro aspecto de interés es la detección de patrones estacionales, es bien sabido también que el turismo es un sector estacional, que varía mucho según el periodo del año. Sin embargo los patrones pueden ser distintos según la zona. Mientras que algunas experimentan una gran subida en invierno, otras experimentan una bajada. El objetivo es ver cuales son los comportamientos cíclicos para cada zona. 

Entonces, hay dos enfoques para analizar las series de temporales, el enfoque clásico y el llamado de Box_Jenkins. Haremos ambos para ver cual proporciona una mejor aproximación.

```{r Librerías}
library(forecast)
library(dplyr)
```

```{r Inicialización de las variables}
# Hay que convertir los datos a una serie temporal de la librería forecast, dado que hay que hacerlo para cada CC.AA. mejor hacer una función
Convertir_en_Serie <- function(vector, Anio_Inicio, Mes_Inicio, Anio_Final, Mes_Final, frec){
  return(ts(vector, start = c(Anio_Inicio, Mes_Inicio), end = c(Anio_Final, Mes_Final), frequency = frec))
}
```


### Análisis clásico

```{r Función para el análisis clásico}
Diferencias <- function(serie){
  return(serie[2:length(serie)] - serie[1:(length(serie) - 1)])
}
Cocientes <- function(serie){
  return(serie[2:length(serie)] / serie[1:(length(serie) - 1)])
}
CV <- function(serie){
  return(sd(serie, na.rm=T) / mean(serie, na.rm=T))
}

Analisis_Clasico <- function(Serie){
  # Calculo de la componente tendencial
  Tendencia <- forecast::ma(Serie, order = frequency(Serie), centre = TRUE)
  # Hay que ver si tomamos el esquema aditivo o multiplicativo
  if ( CV(Diferencias(Serie)) < CV(Cocientes(Serie)) ){
    # En este caso el modelo debe ser aditivo
    Serie_Sin_Tendencia <- Serie - Tendencia
    Medias_Est <- tapply(Serie_Sin_Tendencia, cycle(Serie_Sin_Tendencia), mean, na.rm = TRUE)
    Medias_Est <- Medias_Est - mean(Medias_Est)
    Estacional <- ts(rep(Medias_Est, length.out = length(Serie)),
                 start = start(Serie), frequency = frequency(Serie))
    Ruido <- Serie_Sin_Tendencia - Estacional
    return(list(type = "Aditivo", trend = Tendencia, seasonal = Estacional,
       remainder = Ruido, fitted = Tendencia + Estacional))
    
  } else {
    # El caso contrario será multiplicativo
    Serie_Sin_Tendencia <- Serie / Tendencia
    Medias_Est <- tapply(Serie_Sin_Tendencia, cycle(Serie_Sin_Tendencia), mean, na.rm = TRUE)
    Medias_Est <- Medias_Est / mean(Medias_Est)
    Estacional <- ts(rep(Medias_Est, length.out = length(Serie)),
                 start = start(Serie), frequency = frequency(Serie))
    Ruido <- Serie_Sin_Tendencia / Estacional
    return(list(type = "Multiplicativo", trend = Tendencia, seasonal = Estacional,
       remainder = Ruido, fitted = Tendencia * Estacional))
  }
}
```

```{r Prediccion medelo clásico}
# Serie: es el tramo de la serie con el que se entrenará el modelo
# Serie
PrediccionHW <- function(Serie, Serie_test, H, tipo){
  if (tipo == "Aditivo"){
    Modelo <- HoltWinters(Serie, seasonal = "additive")
  }else if (tipo == "Multiplicativo"){
    Modelo <- HoltWinters(Serie, seasonal = "multiplicative")
  }
  pred <- predict(Serie_Suavizada_Add, n.ahead=12)
  ts.plot(Serie_test, 
          pred, 
          lty=1:2,  
          xlab="Tiempo", 
          title="Modelo")
}
```


Haremos una función para conocer los errores de los modelos

```{r Errores}
Errores <- function(Serie, Predic){
  rmse <- sqrt(mean((Serie - Predic)^2))
  mape <- 100*mean(abs(Serie - Predic) / Serie)
  return(list(rmse = rmse, mape = mape))
}
```

### Análisis de Box-Jenkins

También es necesario hacer predicciones y ver la calidad de estas. La idea es hacer un ARIMA.

```{r Predicciones}
# Serie: es la serie que se usará para entrenar el modelo
# Serie_test: es la serie queremos predecir
# H: es el número de periodos en el futuro que se va a predecir, debe pasar que Serie_test, tenga longitud H

Prediccion <- function(Serie, Serie_test, H){
  
  # Código de ayuda por si fuera necesario hacer debuging
  # browser()
  # Modelo <- arima(Serie, order=c(1,0,1), seasonal=list(order=c(1,1,1), period=12))
  
  Modelo <- auto.arima(Serie, stepwise=FALSE, approximation=FALSE)
  
  pred <- forecast(Modelo, h=H)
  
  # Un dataframe con la predicción
  df_forecast <- data.frame(
    tiempo = as.numeric(time(Serie_test)),
    valor = as.numeric(pred$mean),
    tipo = "Prediccion")
  
  # Un dataframe con los datos originales del periodo que vamos a predecir
  df_serie1 <- data.frame(
    tiempo = as.numeric(time(Serie_test)),
    valor = as.numeric(Serie_test),
    tipo = "Serie")
  
  # Un dataframe con la serie que se ha usado para entrenar
  df_serie2 <- data.frame(
    tiempo = as.numeric(time(Serie)),
    valor = as.numeric(Serie),
    tipo = "Serie")
  
  # dataframe con los datos ajustados por el modelo
  df_ajuste <- data.frame(
    tiempo = as.numeric(time(Serie)),
    valor = as.numeric(Serie - residuals(Modelo)),
    tipo = "Ajuste")
  
  df1 <- bind_rows(df_serie2, df_ajuste)
  df2 <- bind_rows(df_serie1, df_forecast)
  
  grafica_Ajuste <- ggplot(df1, aes(x = tiempo, y = valor, color = tipo)) + 
    geom_line(size = 1) +
    labs(title = "Gráfica de ajuste")
  
  grafica_Prediccion <- ggplot(df2, aes(x = tiempo, y = valor, color = tipo)) + 
    geom_line(size = 1) +
    labs(title = "Gráfica de predicción")
  
  Serie_aux <- ts(as.numeric(pred$mean), 
                  start=start(Serie_test), 
                  end=end(Serie_test),
                  frequency=frequency(Serie_test))
  
  return(list(Prediccion = pred, 
              Grafica_Ajuste = grafica_Ajuste, 
              Grafica_Predic = grafica_Prediccion,
              errores_predic = Errores(Serie_test, Serie_aux),
              errores_ajuste = Errores(Serie, Serie - residuals(Modelo)) ))
}
```

## Importación de los datos

```{r Importación}
load("Data/df_Turismo_clean_mensual.RData")
```

## Creación serie de tiempo

```{r Creación series temporales}
Creacion <- function(comunidad){
  return(Convertir_en_Serie(df_Turismo[df_Turismo$CCAA == comunidad,]$Total, 1999, 1, 2025, 9, 12))
}
Series <- lapply(levels(df_Turismo$CCAA), Creacion)
names(Series) <- levels(df_Turismo$CCAA)
```

Ahora vamos a hacer gráficos para cada comunidad autónoma.

```{r Gráficos estacionales}
Graficos_Estacionales <- mapply(function (x, nombre) {ggseasonplot(x, 
             year.labels=T, 
             year.labels.left=F,
             ylab = "Turismo",
             main =paste("Ocupación en", nombre, sep=" "))},
       Series,
       names(Series))

Graficos_Estacionales
ts.plot(Series[[1]])
```

## Análisis de la serie

Dado que nuestro objetivo es ver si los datos del periodo correspondiente a la vigencia de la pandemia se pueden eliminar o no, vamos a crear una subserie para cada comunidad que abarque desde el inicio de los datos hasta el inicio del confinamiento en España.

Esa fecha es el 14 del mes de marzo de 2020, como se produce mitas, así que lo que haremos es tomar el periodo desde el inicio de los registros, hasta febrero de 2020.

```{r Seleccion periodo prepandemia}
PrePandemia <- lapply(Series, function(x) window(x, start=start(x),end=c(2020, 2)))
PostPandemia <- lapply(Series, function(x) window(x, start=start(x),end=c(2020, 2)))
```

Ahora hacemos el análisis con las funciones que hemos definido antes. 

```{r Recorte}
Recorte <- function(serie, fechaIni=c(2022,3), fechaFin=c(2023, 2)){
  serie_nueva <- ts(serie, start=fechaIni, end=fechaFin, frequency = 12)
}
 
PostPandemia <- lapply(Series, Recorte)
```


```{r Prediccion para todas las CCAA}
AnalisisBox <- mapply(Prediccion, PrePandemia, PostPandemia, rep(12,10))
system.time(mapply(Prediccion, PrePandemia, PostPandemia, rep(12,10)))
AnalisisClasic <- lapply(PrePandemia, Analisis_Clasico)
```

```{r}
saveRDS(AnalisisBox, file = "AnalisisBox.rds")
Analisis <- readRDS("AnalisisBox.rds")
```


```{r}
for (i in 1:95){
  ccaa <- levels(df_Turismo$CCAA)
  nombres1 <- paste("Graficos_Series/Grafico_Ajuste", ccaa, sep = "_")
  nombres2 <- paste("Graficos_Series/Grafico_Prediccion", ccaa, sep = "_")
  if (i %% 2 == 0){
    ggsave(paste(nombres1[i],".pdf", sep=""), plot = AnalisisBox[[i]])
  }else if(i %% 3 == 0){
    ggsave(paste(nombres2[i], ".pdf", sep=""), plot = AnalisisBox[[i]])
  }
}
```


```{r}
HacerPrediccion <- function(Serie, Serie_test, Analisis){
  return(PrediccionHW(Serie, Serie_test, 12, Analisis["type"]))
}

Prediccion <- mapply(HacerPrediccion, PrePandemia, PostPandemia, AnalisisClasic)
```

